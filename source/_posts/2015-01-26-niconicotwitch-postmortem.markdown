---
layout: post
title: "NicoNicoTwitch Postmortem"
date: 2015-01-26 18:52:05 -0800
comments: true
categories: ["javascript", "project", "postmortem"]
---

<a href="https://github.com/lee-jason/Random_Projects/tree/master/niconicotwitch">Source code</a>

NicoNicoTwitch is a javascript canvas project that's meant to bring over the unique on-screen scrolling commentary feature of <a href="http://niconico.jp">Nico Nico Douga</a> onto the popular game live streaming platform <a href="http://twitch.tv">twitch.tv</a>. I made this because I always loved Nico's unique text-on-video overlay of community commentary and wanted to bring that over to Twitch who also sports a vibrant commentary community. I personally think that bringing the chat more closer to the video gives us a closer connection to those on the people on the web as you can relate when you both find a certain scene uproaringly hilarious, or another particular scene sad. Twitch was the perfect video playing platform to emulate this feature on due to the chat being in real time as well as being quite infectious with its commentary.

<!-- more -->

The basic rundown of how niconicotwitch works is pretty straightforward. Set a timer to read any updates in the chat, when there's new messages, parse and process them for any emoticons, send them to the display sorter where it'll find a spot for them to 'marquee', then animate the text as it flies by.  The jQuery library was used for its convenience in dom selection and traversal through all the chat elements and the html5 canvas feature was used to paint the text over the video. The following will go into a bit further detail about the intricacies of the program.

<h2>Running it</h2>
So how do you run it? Well, at this point there is no proper executable.  Its simply a hack that's supposed to be ran through the browser javascript console.  Just go to a twitch streamer page with chat (i.e. not the homepage) open the console (f12) and paste the code in. Make sure the chat is open so that the dom is actually updating and receiving messages. You may hide the chat window after its initialized as it will keep getting messages while hidden. I'm not exactly sure how to package this up if I want to release it publically.  I hear Chrome Apps is pretty easy to use in terms of packaging up js applications but to be honest, sharing this wasn't my priority, it was mainly done for the practice.

<h2>The Nitty Gritty</h2>
So what happens when you paste the code in your console?  First, I use jQuery to identify where the flash element is on the screen and overlay a new Canvas element directly over it. This canvas element is transparent and will be used for our flying text. I insert the 'Initialized' text message into the message processing queue where the message is then processed and inserted into a TextObject where it is given its current x and y coordinates as well as the width of the message, the speed at which it'll be flying across the screen, the color of its user, and of course the text message itself. 

<h3>Inserting the Text</h3>
The <code>insertText</code> function decides the initial location of the text on the screen. New messages captured from the dom get passed into this function.  I gave two rules to deciding the text location.
<ol>
    <li>new text shall be placed as close to the top as possible</li>
    <li>text should never overlap each other.</li>
</ol>
Ensuring that text wouldn't overlap each other essentially required that the incoming message wouldn't start to leave before the already outgoing message left the screen. This required a bit of math involving the velocity of text, the framerate, the canvas width, the width of the text itself, and the width of any emoticons inside it. I was very fortunate that canvas already supplies a method that measures the width of any supplied text with <code>context.measureText("text")</code>.  This took out the grunt work of measuring each pixel width of each letter individually and calculating the width of text messages letter by letter. I was unsure of whether my <code>insertText</code> function was going to work until I implemented my animator.

<h3>Updating the Screen</h3>
My animate function is pretty straight forward.  Clear the canvas screen, update my location of my each of my text objects based on their given velocity, draw the text back on the screen. When all is over, it calls a global function <code>requestAnimFrame</code> that calculates when to call the animate function again. Currently the Frames Per Second (FPS) is set at 30, so each animation frame triggers every 33.3ms. The FPS is completely adjustable through a variable but I think it looks best at 30.  If I didn't time the animation frames to run in a constant manner, text would probably speed by unnaturally fast as the program would be running the animate function as fast as it could.

<h3>Parsing the DOM + Messages</h3>
Okay! We got our animate and we have our insertText function, now we just need to read the messages from the chatbox.  There's another timer that triggers every second to read messages from the chatbox. It only reads up to the latest message that it hasn't seen before and sends it to the <code>insertText</code> function. This is entirely done with jQuery doing the heavy work in searching the dom tree.  What was probably the most challenging here was parsing the html to grab only the information I wanted with regular expressions.  I'm not particular with regular expressions but it was good to practice my matching abilities. What was most surprising to me though was that javascript's <code>RegExp.prototype.exec()</code> only returns the first match.  If there are multiple matches in the text for the same regular expression, you need to keep going in a while loop until the exec() returns a null.  Why was it designed this way?  I think that's very counter intuitive. The reason why I needed to exec multiple times on the same string was to catch multiple uses of emoticons in the same message which as we know twitch chat loves spamming which makes this a very valid use case.

<h3>Parsing the Emoticons</h3>
Of course getting emoticons to appear on the canvas object was not as easy as I thought. I needed to parse out the emoticon html, identify the graphic url, identify the graphic keyword, and have the animate function insert a picture in between the text messages. Before twitch used to display their emoticons using <span\> tags that had background-images in css. Since twitch has an ever updating emoticon list, I had to preload all possible emoticons and identify each emoticon's url by going through each loaded span and identifying its background-image. Of course this wasn't really that great due to having to pre-load more than 10,000 emoticons before running the program. With the emoticon update (which according to the blog updated 4 days ago) twitch made it way easier to identify the url for each emoticon since they now use an actual <img\> tag that has the src right inside it.  Now I use a system that lazily loads the needed emoticon only when the user uses it in chat.

Well that was a long boring read but actually watching it come together is something like magic.  Its fun seeing two messages on the same line coming close to colliding but actually just barely miss each other.  Its also fun when there's alot of chatters filling up the entire screen cheering with excitement at big plays or sharing some sympathy with a solitary BibleThump.

<h2>The Annoyances</h2>
Of course with such a successful project there are always some things I'd like to improve on if I even want to go back to this. It can always be more polished obviously but I'm happy at the point that its at now. I can parse the text to beautify html anchor tags. I can create an actual emoticon object that keeps track of each unique emoticon's size since as of now I give each emoticon around 40 pixels of space. I can refactor the code just sitting out in the open in the nicoNicoTwitch function into its respective config, init, or manager classes instead of barfing everything in the same js file (of course this was before I knew about require.js). I can also clean up comments commenting out code that I don't like.  I think as of writing this :) and <3 are not processed correctly by the emoticon parsing system. I also think there's a better way to read new messages from the chatbox than to check it every second. If I had more time and willingness I think it could be accomplished by hijacking whatever js function is being used to create new dom messages and making it send a custom event to my program saying that there's a new message.  I don't actually have much experience with custom javascript events so this actually sounds like a good research opportunity for my next project. But with all these annoyances that are actually under my control, the one true annoyance is with twitch itself.  Its not that I can blame them, but everytime they update their system to use a different identifier, different dom structure, different emoticon keyword, different emoticon url, my program breaks. The fact that my program is completely dependent on them not changing anything to their site is the greatest annoyance.  Of course, this was before I knew about their public API which probably exposes the irc channels each user's chat is hosted on, but oh well, that's the problem with development right, no one is omnipotent.